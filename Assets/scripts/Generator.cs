using System.Collections;
using UnityEngine;

/* 
 * Written this semester, starting at line 14.
 * This script is placed on the generator GameObject. When it is told to Start by other scipts it will:
 * 1. Cause the generator to shake violently, like all good generators do.
 * 2. Open an elecric door
 * 3. Prevent the generator from starting agian.
 */
//This one line was generated by unity
public class Generator : MonoBehaviour
{
    //The door object to open.
    public GameObject door;

    [HideInInspector]
    //Answers these questions: Is the geneator running? Has it already started?
    public bool hasStarted = false;

    [HideInInspector]
    //This bool is not used in this script, however other scripts will change and get this value.
    public bool hasGas = false;

    //The maximum range the generator can shake. This value is actually doubled since the generator shakes from -shakeRange to shakeRange.
    public Vector3 shakeRange = new(0.1f, 0.1f, 0.1f);
    //How many frames will pass before it chooses an new location to move, when shaking.
    //This way we can control how fast it shakes. The higher the value the slower it gets.
    public int speed = 2;

    //Called when a script wants the generator to start.
    public void StartGenerator()
    {
        if (!hasStarted && hasGas)
        {
            // 1, Starts the shaking annimation
            StartCoroutine("StartShaking");
            // 2, Opens the door by moving it up.
            StartCoroutine("OpenDoor");
            // 3, Sets this bool to true so the script knows that it cannot start agian.
            hasStarted = true;
        }
    }

    //Opens the door by moving it up slowly.
    IEnumerator OpenDoor()
    {
        //Wait seven seconds so the player can see the door opening if they wanted to.
        yield return new WaitForSeconds(7);
        //Save the position of the door
        Vector3 oldPostion = door.transform.position;
        //Loop until the door moves more than it's scale upward, effectivly moving up one length of it's self.
        while(door.transform.position.y < (oldPostion + new Vector3(0, door.transform.lossyScale.y, 0)).y)
        {
            //How much the door will move this frame. The possability of a negitive value make the movment look jagged, like it is struggling to open.
            Vector3 doorMove = new(0, Random.Range(-0.01f,0.02f), 0);

            //Apply the movment vector
            door.transform.position += doorMove;
            yield return new WaitForEndOfFrame();
        }
    }
    IEnumerator StartShaking()
    {
        //Get the part of the generator that will shake.
        GameObject main = transform.GetChild(1).gameObject;
        //Saves the origanal position of the part that shakes.
        Vector3 vector3 = main.transform.position;
        //Saves the position it came from, lastPosition, and the position it is going, newPosition. These are in local space and usally very small.
        Vector3 lastPosition = Vector3.zero;
        Vector3 newPosition = Vector3.zero;
        //Acts as a counter
        int i = speed;
        //When started, this annimation will continue forever until the application shuts down, or you know, crashes.
        while (true)
        {
            //Wait for the next frame every time its loops
            yield return new WaitForEndOfFrame();
            //The counter will increase by one every frame.
            i++;
            if (i >= speed)
            {
                //When the counter is more than "speed" a new location to travel to is chossen and the counter is reset.
                //Save the position we are at now so we know were we came from.
                lastPosition = newPosition;

                //Choose random values for x, y, and z
                newPosition = Random.insideUnitSphere;
                newPosition.x *= shakeRange.x;
                newPosition.y *= shakeRange.y;
                newPosition.z *= shakeRange.z;

                //Reset counter
                i = 0;
            }
            else
            {
                //If i is less than speed, than this frame we interpolate from last position to the new position, using the counter to descide how close we are to the target position.
                main.transform.position = vector3 + Vector3.Lerp(lastPosition, newPosition, (float)i / speed);
            }
        }
    }
}
