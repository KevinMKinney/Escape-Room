using System.Collections;
using System.Collections.Generic;
using UnityEngine;//everything before this is auto generated
using System.Linq;//need this for functional refactoring
using System;//need this for math functions

public class PlayerPhysics : MonoBehaviour
{
    private GameObject player;
    private GameObject pickedUpItem;
    public float weight;
    private PlayerObject pObj;
    private GameObject[] allObjects;//for collisions
    private ItemObject[] itemObjects;

    
    // Start is called before the first frame update
    void Start()//auto generated by unity
    {
        player = GameObject.Find("Player");
        pObj = new PlayerObject(new Vector3(0, 0, 0), new Vector3(0, 0, 0), new Vector3(0, 0, 0), weight );
        
        //set up the mesh to be used
        Vector3 mP = FindObjectOfType<MapDisplay>().textureRender.transform.position;
        Vector3[] mV = FindObjectOfType<MapDisplay>().meshFilter.mesh.vertices;
        Vector3 bounds = FindObjectOfType<MapDisplay>().textureRender.transform.localScale;
        pObj.setMeshInfoUp(mV, mP, bounds);

        //put the player past the border of the mesh
        player.transform.position = pObj.meshPosition + new Vector3(0.05f, 0, 0.05f);
        pObj.Position = player.transform.position;
        //filter this out for things that are not items to collide with, static amount of items
        allObjects = UnityEngine.Object.FindObjectsOfType<GameObject>().
                                                            Where(item => item.tag == "Item").ToArray();
        itemObjects = allObjects.Select(item => item.GetComponent<ItemPhysics>().getItem()).ToArray();
        pickedUpItem = null;
       
    }

    void Update()//this was generated by unity
    {
        pObj.collide(itemObjects);//collisions with items
        //need to set up picking up and dropping items
        //for picking up items in game
        if((Input.GetKey(KeyCode.P))){
            GameObject[] closeObjs = allObjects.Where(x => PlayerObject.getDistance(pObj.Position, x.transform.position) < 2).ToArray();
            if(closeObjs.Length != 0){
                //move item far away, disappear and then store it to drop later
                pickedUpItem = closeObjs[0];
                closeObjs[0].GetComponent<ItemPhysics>().setPickedUpItem(true);
                closeObjs[0].GetComponent<ItemPhysics>().getItem().Position.y = -100;
            }
        }
        //if user hits d key and has something to drop
        if((Input.GetKey(KeyCode.D)) && pickedUpItem != null){
            pickedUpItem.GetComponent<ItemPhysics>().getItem().Position = pObj.Position + new Vector3(1, 1, 1);
            pickedUpItem.GetComponent<ItemPhysics>().setPickedUpItem(false);
            pickedUpItem = null;
        }

        //move the player based on the key inputs and borders
        pObj.move(pObj.zBounds, pObj.xBounds, pObj.meshPosition);
        //looks at location at all time to determine height, based on the vertices
        float temp = pObj.getHeight(pObj.bounds, pObj.meshVertices, pObj.meshPosition);
        if(pObj.Position.y - temp < 1 && pObj.Velocity.y <= 0){
             //use mesh vertices to determine where we should be above of   
            pObj.Position.y = temp + .9f;
            pObj.isGrounded = true;
        }

        //if player wants to jump, then jump
        if((Input.GetKey("space") && Input.anyKey) && pObj.isGrounded){
            pObj.jump();
        }

        if(pObj.isGrounded){//if player is on the ground, then we should be able to move still
            pObj.Velocity.y = 0;
            player.transform.position = pObj.physWorld.move(Time.deltaTime, pObj, pObj.isGrounded);
        }
        //if not on the ground, then player must fall
        else player.transform.position = pObj.physWorld.move(Time.deltaTime, pObj, pObj.isGrounded);

        //if we are moving, got to slow us down
        if(pObj.Velocity.x != 0){
            pObj.Velocity.x = pObj.friction(pObj.Velocity.x, 0.5f);
        }
        if(pObj.Velocity.z != 0){
            pObj.Velocity.z = pObj.friction(pObj.Velocity.z, 0.5f);
        }
    }

}